## 前言

来补一下暑期集训的坑。

**注：这篇博客上的所有内容在 OI Wiki 上均有提到，所以博客水准仅供笔者复习巩固。**

## 正文

### 标记可持久化

这个很好理解，在进行区间修改的时候，不下传懒标记，查询的时候直接对每一层再进行处理即可。

这个主要用于线段树分治和可持久化方面的内容，也能优化常数。不过容易使节点信息溢出，所以一般不用。

### 动态开点

之前一直不太会，现在来补一下。

这种线段树主要用于优化空间复杂度。就是对于下标，不用常规方法存储节点的左右儿子，而用一个单独的变量 $tot$ 来存储。

这点大家作为资深 OIER 一定都懂，下面说一下代码方面和普通线段树的区别。

在写函数的时候，需要额外定义当前节点所代表的区间的信息。

本人喜欢用结构体存储，所以需要在结构体里面增加 $lc,rc$ 代表儿子下标，并且用宏定义优化代码长度。在调用的时候将 $t_{t_{p*2}.lc}$ 改为 $t_{lc(p)}$ 即可，右儿子同理。

懒标记部分判断一下 $lc,rc$ 是否被赋值，如果没有让 $tot++$ 然后再去赋值就行了。

区修部分需要额外开一个变量 $p$ 来表示当前节点编号，函数里面用实参调用 $p$，这样方便对 $lc,rc$ 进行赋值，其余不变。

查询部分只需要在最开始判断一下当前编号是否已经被赋值，如果没有直接返回。这也是动态开点线段树优化空间的直接表现。

稍微放下洛谷线段树模板一的代码，最开始的时候忘记 $upd$ 了，查了好久才发现~~我太菜了~~。

<details>
<summary>点击查看代码</summary>

```cpp
#include<bits/stdc++.h>
#define int long long
const int maxn=1e6+10;
using namespace std;
inline int read()
{
	int w=1,s=0;char ch=getchar();
	while(!isdigit(ch)){if(ch=='-')w=-1;ch=getchar();}
	while(isdigit(ch)){s=s*10+(ch-'0');ch=getchar();}
	return w*s;
}
int n,Q,tot,st;
struct no
{
	int d,add;
	int lc,rc;
	#define lc(x) t[x].lc
	#define rc(x) t[x].rc
}t[maxn<<2];
void upd(int p)
{
	t[p].d=t[lc(p)].d+t[rc(p)].d;
}
void spread(int p,int tl,int tr)
{
	if(!t[p].add)return ;
	int mid=(tl+tr)>>1;
	if(!lc(p))t[p].lc=++tot;
	if(!rc(p))t[p].rc=++tot;
	t[lc(p)].d+=t[p].add*(mid-tl+1);
	t[rc(p)].d+=t[p].add*(tr-mid);
	t[lc(p)].add+=t[p].add;
	t[rc(p)].add+=t[p].add;
	t[p].add=0;
}
void add(int &p,int tl,int tr,int l,int r,int k)
{
	if(!p) p=++tot;
	if(tl>=l&&tr<=r)
	{
		t[p].d+=k*(tr-tl+1);
		t[p].add+=k;
		return ;
	}
	spread(p,tl,tr);
	int mid=(tl+tr)>>1;
	if(mid>=l)add(lc(p),tl,mid,l,r,k);
	if(mid<r)add(rc(p),mid+1,tr,l,r,k);
	upd(p);
}
int ask(int p,int tl,int tr,int l,int r)
{
	if(!p)return 0;
	if(tl>=l&&tr<=r)return t[p].d;
	spread(p,tl,tr);
	int mid=(tl+tr)>>1,ma=0;
	if(mid>=l)ma+=ask(lc(p),tl,mid,l,r);
	if(mid<r)ma+=ask(rc(p),mid+1,tr,l,r);
	return ma;
}
signed main()
{
	cin>>n>>Q;
	for(int i=1;i<=n;i++)
	{
		int x=read();
		add(st,1,n,i,i,x);
	}
	while(Q--)
	{
		int opt=read(),l=read(),r=read();
		if(opt==1){int k=read();add(st,1,n,l,r,k);}
		else printf("%lld\n",ask(st,1,n,l,r));
	}
	return 0;
}
```
</details>

### 线段树合并

这个东西找不到模板题目，看了看用到它的东西都是树剖以上的算法，所以就讲一下部分实现吧。

其实很简单，对两个线段树维护的信息进行合并，需要更新下标和维护内容。

下标的话只需要特判一下是否存在，然后不存在的话新开一个节点就行，维护内容的话就正常处理。

代码很短，不想写了。

线段树分裂的话是科技产品，这里不提了。

### 线段树优化建图

这个比前面的稍微难一点，不过也还行。

放一道[模板题](https://www.luogu.com.cn/problem/CF786B)。

考虑建图的时候如果需要让一个节点和一个区间内的所有节点连边，那么正常情况下会爆时间。

所以我们把连边操作放到线段树里面。连边时，我们只需要让节点对对应区间连边即可。

但是如果有无向边的话，一颗线段树会乱套，所以我们建两棵线段树，分别存储点连向线段树区间节点和线段树区间结点连向点的边。下文我们称它们分别为入树和出树。

最开始的时候，我们让入树中左右节点连向它的两个儿子，出树则让儿子连向它的父亲节点，都是有向边，边权为 $0$。同时让两棵树对应位置的所有叶节点也连上边权为 $0$ 的无向边，这样两棵线段树就完成了初始化。

对于编号的话，我们让入树的节点编号正常搞，出树则根据数据范围加上一个偏移量 $k$。对于所有叶节点，我们用一个数组 $id$ 表示原数组中的位置在入树中所对应的叶节点编号，然后对于出树，叶节点编号直接就是 $id_i+k$ 了。

以点连向区间为例，我们让出树中对应的叶节点连向入树中覆盖该区间的节点，借用一下 maoyiting 大佬的图
![image](https://img2024.cnblogs.com/blog/3059767/202407/3059767-20240724161528445-949586988.png)
另一种操作同理。

模板题要求跑单源最短路，那么我们找到起点在出树中所对的编号，然后正常 dijkstra 即可。

当然，我们还有一道[模板题](https://www.luogu.com.cn/problem/P6348?contestId=191937)。这道题是区间连区间，我们只需要对第一个区间所有需要连的点存进一个数组，然后对于第二个区间，递归找的时候每找到一个就对这个数组里面的所有点进行连边，这样建边的复杂度是 $\mathcal{O}(mlog^2n)$ 的，常数比较大。

<details>
<summary>第一题的代码</summary>

```
#include<bits/stdc++.h>
#define int long long
inline int read()
{
	int w=1,s=0;char ch=getchar();
	while(!isdigit(ch)){if(ch=='-')w=-1;ch=getchar();}
	while(isdigit(ch)){s=(s<<1)+(s<<3)+(ch^48);ch=getchar();}
	return w*s;
} 
using namespace std;
const int maxn=2e6+100;
int n,m,s,k;
struct Seg
{
	int l,r;
}t[3000100];
struct no
{
	int y,v;
};
vector<no> G[maxn];
void add(int x,int y,int v)
{
	G[x].push_back({y,v});
}
int id[maxn];
void build(int p,int l,int r)
{
	t[p].l=l,t[p].r=r;
	if(l==r)
	{
		id[l]=p;
		return ;
	}
	int mid=(l+r)>>1;
	add(p,p*2,0);add(p,p*2+1,0);
	add(p*2+k,p+k,0);add(p*2+1+k,p+k,0);
	build(p*2,l,mid);
	build(p*2+1,mid+1,r);
}
void change(int p,int l,int r,int x,int v,int opt)
{
	if(t[p].l>=l&&t[p].r<=r)
	{
		if(opt==2)add(x+k,p,v);
		else add(p+k,x,v);
		return ;
	}
	int mid=(t[p].l+t[p].r)>>1;
	if(l<=mid)change(p*2,l,r,x,v,opt);
	if(mid<r)change(p*2+1,l,r,x,v,opt);
}
struct dii
{
	int y,id;
	inline friend bool operator < (dii x,dii y)
	{
		return x.y>y.y;
	}
};
int dis[maxn];
bool vis[maxn];
void distla(int s)
{
	memset(dis,0x3f,sizeof dis);
	priority_queue<dii> q;
	dis[s]=0;
	q.push({0,s});
	while(!q.empty())
	{
		int u=q.top().id;
		q.pop();
		if(vis[u])continue;
		vis[u]=1;
		for(auto i : G[u])
		{
			int y=i.y,v=i.v;
			if(dis[u]+v<dis[y])
			{
				dis[y]=dis[u]+v;
				if(!vis[y])
				q.push({dis[y],y});
			}
		}
	}
}
signed main()
{
	cin>>n>>m>>s;
	k=5e5;
	build(1,1,n);
	for(int i=1;i<=n;i++)
	{
		add(id[i],id[i]+k,0);
		add(id[i]+k,id[i],0);
	}
	for(int i=1;i<=m;i++)
	{
		int opt=read(),x=read();
		if(opt==1)
		{
			int y=read(),v=read();
			add(id[x]+k,id[y],v);
		}
		else if(opt==2||opt==3)
		{
			int l=read(),r=read(),v=read();
			change(1,l,r,id[x],v,opt);
		}
	}
	distla(id[s]+k);
	for(int i=1;i<=n;i++)
	cout<<(dis[id[i]]==0x3f3f3f3f3f3f3f3fll?-1:dis[id[i]])<<' ';
	return 0;
}
```
</details>

<details>
<summary>第二题的代码</summary>

```cpp
#include<bits/stdc++.h>
// #include <ext/pb_ds/assoc_container.hpp>
// #include <ext/pb_ds/tree_policy.hpp>
#define int long long
using namespace std;
// using namespace  __gnu_pbds;
// tree<int,null_type,less<int>,rb_tree_tag,tree_order_statistics_node_update> tr;//从小到大
// int findnum(int k){auto it=tr.find_by_order(k-1);return ((it!=tr.end())?(*it):1e9+7);}//查元素
// int findrank(int x){return tr.order_of_key(x)+1;}//查排名
inline int read()
{
	int w=1,s=0;char ch=getchar();
	while(!isdigit(ch)){if(ch=='-')w=-1;ch=getchar();}
	while(isdigit(ch)){s=s*10+(ch-'0');ch=getchar();}
	return w*s;
}
const int mod=1e9+7;
const int maxn=1e6+10;
const int inf=1e17;
const double eps=1e-10;
int n,m,s,k;
struct Seg
{
	int l,r;
}t[5000100];
struct no
{
	int y,v;
};
vector<no> G[maxn];
void add(int x,int y,int v)
{
	G[x].push_back({y,v});
}
int id[maxn];
void build(int p,int l,int r)
{
	t[p].l=l,t[p].r=r;
	if(l==r)
	{
		id[l]=p;
		return ;
	}
	int mid=(l+r)>>1;
	add(p,p*2,0);add(p,p*2+1,0);
	add(p*2+k,p+k,0);add(p*2+1+k,p+k,0);
	build(p*2,l,mid);
	build(p*2+1,mid+1,r);
}
vector<int> vv;
void change(int p,int l1,int r1)
{
	if(t[p].l>=l1&&t[p].r<=r1)
	{
		vv.push_back(p);
		return ;
	}
	int mid=(t[p].l+t[p].r)>>1;
	if(l1<=mid)change(p*2,l1,r1);
	if(mid<r1)change(p*2+1,l1,r1);
}
void change2(int p,int l1,int r1)
{
	if(t[p].l>=l1&&t[p].r<=r1)
	{
		for(auto i : vv)
		{
			add(i+k,p,1);
			add(p+k,i,1);
		}
		return ;
	}
	int mid=(t[p].l+t[p].r)>>1;
	if(l1<=mid)change2(p*2,l1,r1);
	if(mid<r1)change2(p*2+1,l1,r1);
}
struct dii
{
	int y,id;
	inline friend bool operator < (dii x,dii y)
	{
		return x.y>y.y;
	}
};
int dis[maxn];
bool vis[maxn];
void distla(int s)
{
	memset(dis,0x3f,sizeof dis);
	priority_queue<dii> q;
	dis[s]=0;
	q.push({0,s});
	while(!q.empty())
	{
		int u=q.top().id;
		q.pop();
		if(vis[u])continue;
		vis[u]=1;
		for(auto i : G[u])
		{
			int y=i.y,v=i.v;
			if(dis[u]+v<dis[y])
			{
				dis[y]=dis[u]+v;
				if(!vis[y])
				q.push({dis[y],y});
			}
		}
	}
}
signed main()
{
#ifdef Lydic
    freopen(".in","r",stdin);
    freopen(".out","w",stdout);
#endif
	cin>>n>>m>>s;
	k=5e5+1;
	build(1,1,n);
	for(int i=1;i<=n;i++)
	{
		add(id[i],id[i]+k,0);
		add(id[i]+k,id[i],0);
	}
	for(int i=1;i<=m;i++)
	{
		int l1=read(),r1=read(),l2=read(),r2=read();
		vv.clear();
		change(1,l1,r1);
		change2(1,l2,r2);
	}
	distla(id[s]+k);
	for(int i=1;i<=n;i++)
	cout<<(dis[id[i]]==0x3f3f3f3f3f3f3f3fll?-1:dis[id[i]])<<endl;
	return 0;
}
```
</details>

### 吉司机线段树

这种线段树主要维护区间最值修改。

具体的，给一道[例题](https://acm.hdu.edu.cn/showproblem.php?pid=5306)（luogu的例题维护的东西太多了，作者懒，所以不用了）。

具体的，在这道题里面，线段树对每个节点维护四个信息。分别是最大值 $mx$，最大值个数 $smax$，次大值 $rmax$，区间和 $sum$。

对于区间最值操作，即形如 $\forall x \in [l,r]，a_x=min(a_x,t)$，我们分三种情况讨论：

若 $mx\leq t$，则不操作。

若 $rmax\lt t\lt mx$，则修改 $sum+=smax\times (t-mx)$ 和 $mx=t$，并进行懒标记。

否则不更新，直接递归。

其余的就是正常操作了。

不同的地方主要是 $spread$ 函数，取最小值时信息的修改和 $update$ 函数，这里放一下这几个东西的代码和它们对应的位置（伪代码）。

<details>
<summary>点击查看代码</summary>

```cpp
void update(int p) 
{  
	t[p].sum=t[p*2].sum+t[p*2+1].sum;
	if(t[p*2].mx==t[p*2+1].mx) 
	{
		t[p].mx=t[p*2+1].mx;
		t[p].rmax=max(t[p*2].rmax,t[p*2+1].rmax);
		t[p].smax=t[p*2].smax+t[p*2+1].smax;
	} 
	else if(t[p*2].mx>t[p*2+1].mx) 
	{
		t[p].mx=t[p*2].mx;
		t[p].rmax=max(t[p*2].rmax,t[p*2+1].mx);
		t[p].smax=t[p*2].smax;
	} 
	else 
	{
		t[p].mx=t[p*2+1].mx;
		t[p].rmax=max(t[p*2].mx,t[p*2+1].rmax);
		t[p].smax=t[p*2+1].smax;
	}
}
void work(int p,int k)
{
	if(t[p].mx<=k)return ;
	/*剩下两种情况在这里是等价的*/
	t[p].sum+=(k-t[p].mx)*t[p].smax;
	t[p].mx=k;
	t[p].add=k;
}
void spread(int p)
{
	if(!t[p].add)return ;
	work(p*2,t[p].add);work(p*2+1,t[p].add);
	t[p].add=0;
}
void change()
{
	if()
	{
		work();
		return ;
	}
	spread();
	if()change();
	if()change();
	update();
}
int askmx()
{
	if()
	{
		return t[p].mx;
	}
	spread();
	askmx();
	askmx();
}
int asksum()
{
	if()
	{
		return t[p].sum;
	}
	spread();
	asksum();
	assum();
}
```
</details>

### 扫描线

这玩意网上一堆，也好理解，所以不写了。