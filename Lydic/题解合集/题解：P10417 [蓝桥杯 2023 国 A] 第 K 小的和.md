
## 分析

~~这道题不是板子么。~~

先对序列排序，然后二分答案，设当前答案为 $x$，枚举 $a$ 中的数，然后二分查找 $b$ 中不大于 $x-a$ 的元素个数，累加判断是否不大于 $k$。

然后稍微调一调端点就过了。

## Code

```cpp

#include<bits/stdc++.h>
#include <ext/pb_ds/assoc_container.hpp>
#include <ext/pb_ds/tree_policy.hpp>
#include<ext/pb_ds/hash_policy.hpp>
#include<ext/pb_ds/trie_policy.hpp>
#include<ext/pb_ds/priority_queue.hpp>
#define int long long
using namespace std;
using namespace  __gnu_pbds;
//gp_hash_table<string,int>mp2;
//__gnu_pbds::priority_queue<int,greater<int>,pairing_heap_tag> q;
inline int read()
{
	int w=1,s=0;char ch=getchar();
	while(!isdigit(ch)){if(ch=='-')w=-1;ch=getchar();}
	while(isdigit(ch)){s=s*10+(ch-'0');ch=getchar();}
	return w*s;
}
const int mod=998244353;
const int maxn=1e5+10;
int n,m,k,a[maxn],b[maxn];
bool ch(int x)
{
	int sum=0;
	for(int i=1;i<=n;i++)
	{
		if(a[i]>=x)break;
		int t=upper_bound(b+1,b+m+1,x-a[i])-b;
		t--;
		sum+=t;
	}
	return sum<=k;
}
signed main()
{
	cin>>n>>m>>k;
	for(int i=1;i<=n;i++)a[i]=read();
	for(int i=1;i<=m;i++)b[i]=read();
	sort(a+1,a+n+1);sort(b+1,b+m+1);
	b[m+1]=1e9+7;
	int l=1,r=2e9+10;
	while(l<r)
	{
		int mid=(l+r)>>1;
		if(ch(mid))l=mid+1;
		else r=mid;
	}
	cout<<l;
	return 0;
}
```