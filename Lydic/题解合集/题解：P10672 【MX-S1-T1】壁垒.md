~~暑期集训=依托答辩。~~

## 分析

种类数是奇数一定无解。

否则每种数字先输出一次，在此过程中每增加两个数时，因为每个数字种类数都不一样，所以前缀种类数也同时增加 $2$，保证一定为偶数。

然后输出完以后，设总种类数为 $m$，无论以后再怎么加入新数字，前缀种类数一定为 $m$ 不变，后面数字依次输出就行了。

## Code

```cpp
#include<bits/stdc++.h>
#include <ext/pb_ds/assoc_container.hpp>
#include <ext/pb_ds/tree_policy.hpp>
#include<ext/pb_ds/hash_policy.hpp>
#include<ext/pb_ds/trie_policy.hpp>
#include<ext/pb_ds/priority_queue.hpp>
#define int long long
#define V vector<char> 
using namespace std;
using namespace  __gnu_pbds;
//gp_hash_table<string,int>mp2;
//__gnu_pbds::priority_queue<int,less<int>,pairing_heap_tag> q;
inline int read()
{
	int w=1,s=0;char ch=getchar();
	while(!isdigit(ch)){if(ch=='-')w=-1;ch=getchar();}
	while(isdigit(ch)){s=s*10+(ch-'0');ch=getchar();}
	return w*s;
}
const int mod=998244353;
const int maxn=1e6+10;
int n,a[maxn];
int cnt[maxn];
vector<int> v;
signed main() 
{
	cin>>n;
	for(int i=1;i<=n;i++)a[i]=read();
	sort(a+1,a+n+1);
	for(int i=1;i<=n;i++)
	{
		if(!cnt[a[i]])v.push_back(a[i]);
		cnt[a[i]]++;	
	}
	if(v.size()&1)return 0*printf("-1");
	for(auto i : v)
	{
		cout<<i<<' ';
		cnt[i]--;
	}
	for(int i=1;i<=n;i++)
	{
		for(int j=1;j<=cnt[a[i]];j++)
		{
			cout<<a[i]<<' ';
		}
		cnt[a[i]]=0;
	}
	return 0;
}
```