[比赛链接](http://172.20.0.170/d/jzyz/contest/66c30ddc62afd88c58474dd8)

先看榜：

![image](https://img2024.cnblogs.com/blog/3059767/202408/3059767-20240823142646668-1214567138.png)

倒数呜呜呜。

## T1

最简单的一道题，但是我在看到T2以后就先鸽了，然后就一直鸽了……

简单来想，每次询问只会改变两个数字，所以与处理之后直接和最后的数字一一对应后就可以做到正确的复杂度。

## T2

就是这道题，卡了我3H……

一开始看到的时候直接思路明确。

但是规律找的方法shi了，明显有更简单的方法，但是我直接一条路走到黑，但是最后走出来了（

走出来之后数据结构最开始伪了，后来想到了正解，但是因为没有动态开店而拿到了和暴力一样的分数呜。

放一下找的规律的代码：

<details>
<summary>不堪回首</summary>

```
int calc(int x,int y)
{
        swap(x,y);
        int ans=0;
        if(x>=0)ans=4*x*x-3*x+1;
        else ans=4*x*x-x+1;
        if(x>=0)
        {
            if(y>=0)
            {
                if(y<=x)
                {
                    ans+=y;
                    return ans;
                    
                }
                int delta=y-x-1;
                ans+=x;
                ans+=4*(2*x+delta)*(delta+1)+3*(delta+1);
                return ans;
                
            }
            if(abs(y)<x)
            {
                y*=-1;
                ans-=y;
                return ans;
                
            }
            ans-=(x-1);
            int delta=abs(y)-x;
            y=-x+1;
            ans+=(-4)*(2*y-delta)*(delta+1)+7*(delta+1);
            return ans;
            
        }
        if(y>=0)
        {
            if(abs(x)>=y)
            {
                ans-=y;
                return ans;
                
            }
            int delta=y-abs(x)-1;
            ans+=x;
            x=abs(x);
            ans+=4*(2*x+delta)*(delta+1)+3*(delta+1);
            return ans;
            
        }
        if(abs(x)>=abs(y))
        {
            ans+=abs(y);
            return ans;
            
        }
        int delta=abs(y)-abs(x);
        x=abs(x);
        ans+=x;
        ans=ans+4*delta*(2*x+delta+1)-delta;
        return ans;
}
```
</details>

## T3

因为T2，导致没有一点时间想正解了，所以写了暴力分就鸽了。

正解显然01trie,转移的时候分两种情况统计即可。

## T4

压根没看题，是黑题，但是有一种玄学根号DP做法可以过。
