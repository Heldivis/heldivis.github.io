**因版权问题，题目不能给出，而且设有内置密码**

[比赛链接](http://ng.code-fans.cn:5678/d/jzyz/contest/66a7059325b941123c011cbd)

先放一张榜~~AK了哈哈哈~~
![image](https://img2024.cnblogs.com/blog/3059767/202407/3059767-20240729172725294-217110853.png)

## T1

瞎猜结论，本来想着骗几分，跑两遍最短路，然后发现搞过去了。

后来想一想对于一条路径另外一种方式走的话肯定不优，所以一定不会重叠。

<details>
<summary>点击查看代码</summary>

```
#include<bits/stdc++.h>
#define int short
using namespace std;
inline int read()
{
	int w=1,s=0;char ch=getchar();
	while(!isdigit(ch)){if(ch=='-')w=-1;ch=getchar();}
	while(isdigit(ch)){s=s*10+(ch-'0');ch=getchar();}
	return w*s;
}
const int maxn=5e5+10;
int n,m;
vector<int> G[7000],E[7000];
bool mp[7000][7000];
struct dij
{
	int y,d;
	inline friend bool operator < (dij x,dij y)
	{
		return x.d>y.d;
	}
};
int dis[7000];
bool vis[7000];
void dijk()
{
	priority_queue<dij> q;
	memset(dis,0x3f,sizeof dis);
	memset(vis,0,sizeof vis); 
	dis[1]=0;
	q.push({1,0});
	while(!q.empty())
	{
		int u=q.top().y;
		q.pop();
		if(vis[u])continue;
		vis[u]=1;
		for(auto y : G[u])
		{
			if(dis[u]+1<dis[y])
			{
				dis[y]=dis[u]+1;
				if(!vis[y])q.push({y,dis[y]});
			}
		}
	}
}
void dijkk()
{
	priority_queue<dij> q;
	memset(dis,0x3f,sizeof dis);
	memset(vis,0,sizeof vis); 
	dis[1]=0;
	q.push({1,0});
	while(!q.empty())
	{
		int u=q.top().y;
		q.pop();
		if(vis[u])continue;
		vis[u]=1;
		for(auto y : E[u])
		{
			if(dis[u]+1<dis[y])
			{
				dis[y]=dis[u]+1;
				if(!vis[y])q.push({y,dis[y]});
			}
		}
	}
}
int ans=0;
signed main()
{
//  freopen("xxx.in","r",stdin);
//	freopen("xxx.out","w",stdout);
	cin>>n>>m;
	for(int i=1;i<=m;i++)
	{
		int x=read(),y=read();
//		if(x==y)continue;
		G[x].push_back(y);
		G[y].push_back(x);
		mp[x][y]=mp[y][x]=1;
	}
	for(int i=1;i<=n;i++)
	{
		for(int j=1;j<=n;j++)
		{
			if(i==j||mp[i][j]||mp[j][i])continue;
			E[i].push_back(j);
			E[j].push_back(i);
		}
	}
	dijk();
	ans=dis[n];
	if(ans==dis[0])return 0*puts("-1");
	dijkk();
	if(dis[n]==dis[0])return 0*puts("-1");
	cout<<max(ans,dis[n]);
	return 0;
}
```
</details>

## T2

最开始部分分打满，有 $\color{yellow}70pts$。

然后根据特殊性质思考，分别按照 $x,y$ 排序以后顺次连边即可，这样等效于全部连边，然后就过了。

<details>
<summary>点击查看代码</summary>

```
#include<bits/stdc++.h>
#define int long long
using namespace std;
inline int read()
{
	int w=1,s=0;char ch=getchar();
	while(!isdigit(ch)){if(ch=='-')w=-1;ch=getchar();}
	while(isdigit(ch)){s=s*10+(ch-'0');ch=getchar();}
	return w*s;
}
const int mod=998244353;
const int maxn=1e6+10;
int n;
struct no
{
	int y,v;
};
vector<no> G[maxn];
struct dij
{
	int y,d;
	inline friend bool operator < (dij x,dij y)
	{
		return x.d>y.d;
	}
};
int dis[maxn];
bool vis[maxn];
void dijk()
{
	priority_queue<dij> q;
	memset(dis,0x3f,sizeof dis);
	memset(vis,0,sizeof vis); 
	dis[1]=0;
	q.push({1,0});
	while(!q.empty())
	{
		int u=q.top().y;
		q.pop();
		if(vis[u])continue;
		vis[u]=1;
		for(auto i : G[u])
		{
			int y=i.y,v=i.v;
			if(dis[u]+v<dis[y])
			{
				dis[y]=dis[u]+v;
				if(!vis[y])q.push({y,dis[y]});
			}
		}
	}
}
struct ini
{
	int x,y,id;
	inline friend bool operator < ( ini x,ini y)
	{
		return x.x<y.x||x.x==y.x&&x.y<y.y;
	}
}init[maxn];
bool Sub1=1;
signed main()
{
//	freopen("xxx.in","r",stdin);
//	freopen("xxx.out","w",stdout);
	cin>>n;
	for(int i=1;i<=n;i++)
	{
		int x=read(),y=read();
		init[i]={x,y,i};
		if(x!=y)Sub1=0;
	}
	if(Sub1)
	{
		cout<<abs(init[n].y-init[1].y);
		return 0;
	}
	if(n<=7000)
	{
		for(int i=1;i<=n;i++)
		{
			for(int j=1;j<=n;j++)
			{
				if(i==j)continue;
				int v=min(abs(init[i].y-init[j].y),abs(init[i].x-init[j].x));
				G[i].push_back({j,v});
	//			G[j].push_back({i,v});
			}
		}
		dijk();
		cout<<dis[n];
		return 0;
	}
	sort(init+1,init+n+1);
	int ans=0,st=0,en=0;
	for(int i=1;i<=n;i++)
	{
		if(init[i].id==1)st=i;
		if(init[i].id==n)en=i;
	}
	if(st==1&&en==n)
	{
		for(int i=2;i<=n;i++)
		{
			ans=ans+min(abs(init[i].x-init[i-1].x),abs(init[i].y-init[i-1].y));
			if(init[i].id==n)break;
		}
		cout<<ans;
		return 0;
	}
	else
	{
		for(int i=1;i<n;i++)
		{
			int x=init[i].id,y=init[i+1].id,v=abs(init[i].x-init[i+1].x);
			G[x].push_back({y,v});
			G[y].push_back({x,v});
		}
		sort(init+1,init+n+1,[](ini x,ini y){
			return x.y<y.y||x.y==y.y&&x.x<y.x;
		});
		for(int i=1;i<n;i++)
		{
			int x=init[i].id,y=init[i+1].id,v=abs(init[i].y-init[i+1].y);
			G[x].push_back({y,v});
			G[y].push_back({x,v});
		}
		dijk();
		cout<<dis[n];
	}
}
```
</details>

## T3

好水啊，对每个字母跑一遍最长路，然后更新答案就行了。

最开始加个拓扑判环就做完了。

<details>
<summary>点击查看代码</summary>

```
#include<bits/stdc++.h>
#define int long long
using namespace std;
inline int read()
{
	int w=1,s=0;char ch=getchar();
	while(!isdigit(ch)){if(ch=='-')w=-1;ch=getchar();}
	while(isdigit(ch)){s=s*10+(ch-'0');ch=getchar();}
	return w*s;
}
const int maxn=3e5+10;
vector<int> G[maxn];
int n,m;
int T;
char a[maxn];
int to[maxn],du[maxn];
int ans=-114514;
int dis[maxn];
void Main()
{
	n=read();m=read();ans=-114514;
//	if(m>=n){cout<<-1;return ;}
	for(int i=1;i<=n;i++)cin>>a[i];
	for(int i=1;i<=n;i++)G[i].clear(),to[i]=0,dis[i]=0;
	for(int i=1;i<=m;i++)
	{
		int x=read(),y=read();
		G[x].push_back(y);
		to[y]++;
	}queue<int> q;
	for(int i=1;i<=n;i++)du[i]=to[i];
	for(int i=1;i<=n;i++)if(!du[i])q.push(i);
	while(!q.empty())
	{
		int u=q.front();
		q.pop();
		for(auto y : G[u])
		{
//			if(dis[u]+1>dis[y])dis[y]=dis[u]+1;
//			ans=max(ans,dis[y]);
			if(--du[y]==0)q.push(y);
		}
	}
	for(int i=1;i<=n;i++)
	{
		if(du[i]>0)
		{
			puts("-1");
			return ;
		}
	}
	for(int qw=1;qw<=26;qw++)
	{
		char ch=qw+'a'-1;
		queue<int> q;
		memset(dis,0,sizeof dis); 
		for(int i=1;i<=n;i++)dis[i]=(a[i]==ch?1:0);
		for(int i=1;i<=n;i++)du[i]=to[i];
		for(int i=1;i<=n;i++)if(!to[i])q.push(i);
		while(!q.empty())
		{
			int u=q.front();
			q.pop();
			for(auto y : G[u])
			{
				if(a[y]==ch)dis[y]=max(dis[y],dis[u]+1);
				else dis[y]=max(dis[y],dis[u]);
				if(--du[y]==0)q.push(y);
			}
		}
		for(int i=1;i<=n;i++)ans=max(ans,dis[i]);
	}
	cout<<ans<<endl;
	return ;
} 
signed main()
{
//  freopen("xxx.in","r",stdin);
//	freopen("xxx.out","w",stdout);
	cin>>T;while(T--){Main();}
	return 0;
}
```
</details>

## T4

exdijkstra，求出从起点开始到每一个点所需要的困难程度最大值，把 dijkstra 的松弛操作改为 $dis_v=max(dis_u,V(u,v))$ 即可。

由于题目上要求的是求出走到的种类数，所以再搞一个数组 $d$ 表示这个种类的节点的最小值。

对于每次询问，由于种类数很小，所以枚举每个种类的最小困难程度，那么这一天能到达这个种类的次数就是 $\max(0,r-\max(l,d_i)+1)$ ，累加答案输出就行了。

赛事傻了，把离散化以后得最大值当成种类最大值去当做边界枚举，看了好久才看出来。

<details>
<summary>点击查看代码</summary>

```
#include<bits/stdc++.h>
#define int long long
using namespace std;
inline int read()
{
	int w=1,s=0;char ch=getchar();
	while(!isdigit(ch)){if(ch=='-')w=-1;ch=getchar();}
	while(isdigit(ch)){s=s*10+(ch-'0');ch=getchar();}
	return w*s;
}
const int mod=998244353;
const int maxn=1e6+10;
int n,m,q,x;
int c[maxn];
struct no
{
	int y,v;
};
vector<no> G[maxn];
struct dij
{
	int y,d;
	inline friend bool operator < (dij x,dij y)
	{
		return x.d>y.d;
	}
};
int dis[maxn],d[maxn];
bool vis[maxn];
void dijk()
{
	priority_queue<dij> q;
	memset(dis,0x3f,sizeof dis);
	memset(d,0x3f,sizeof d);
	memset(vis,0,sizeof vis); 
	dis[x]=0;d[c[x]]=0;
	q.push({x,0});
	while(!q.empty())
	{
		int u=q.top().y;
		q.pop();
		if(vis[u])continue;
		vis[u]=1;
		for(auto i : G[u])
		{
			int y=i.y,v=i.v;
			if(max(dis[u],v)<dis[y])
			{
				dis[y]=max(dis[u],v);
				d[c[y]]=min(d[c[y]],dis[y]); 
				if(!vis[y])q.push({y,dis[y]});    
			}
		}
	}
}
map<int,bool> mp;
int tot=0;
signed main()
{
//	freopen("xxx.in","r",stdin);
//	freopen("xxx.out","w",stdout);
	cin>>n>>m>>q>>x;
	for(int i=1;i<=m;i++)
	{
		int x=read(),y=read(),v=read();
		G[x].push_back({y,v});
		G[y].push_back({x,v});
	}
	dijk();
	while(q--)
	{
		int l=read(),r=read();
		int ans=0;
		for(int i=1;i<=610;i++)
		{
			if(d[i]>r)continue;
			ans=ans+r-max(l,d[i])+1;
		}
		printf("%lld\n",ans);
	}
}
```
</details>

## 总结

欧耶
