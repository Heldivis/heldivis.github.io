# 温馨提示：考前路上不要听歌，会洗脑

今天考了山东的普及组补测，然后祭了。
## 比赛流程
### 8:28 开考
### 8:35 TI做完了
### 8:45 T2思路有了 
### 9:10 T2第一份代码WA了
### 9:30 T2二分大概过了
### 10:00 T3不想看了
### 10:30 T4看了大概
### 11:00 T4递归完成，转手看T2
### 11:30 结束

最后的成绩非常不理想，只有130。

失分点主要在T3的图论，原本以为会很难，但是最后发现还行，班上还有不少同学拿了很高的分数，这方面需要加强练习。

同时，T2我的思路已经十分接近正解了，但最后放弃了原有思路，选择了觉得好拿分的二分做法，因此只拿了20分。


## 很水的T1

简单差分，~~有手就行~~。
放个蒟蒻代码
<details>
<summary>点击查看代码</summary>

```
#include<bits/stdc++.h>
using namespace std;
inline int read(){
int w=1,s=0;char ch=getchar();
while(!isdigit(ch)){if(ch=='-') w=-1;ch=getchar();}
while(isdigit(ch)){s=s*10+(ch-'0');ch=getchar();}
return w*s;}
const int Q=2001000;
int n,l=990012,r=-1;
int sum[Q],ans[Q];
int ma=0;
int main()
{
	freopen("planting.in","r",stdin);
	freopen("planting.out","w",stdout);
	cin>>n;
	for(int i=1;i<=n;i++)
    {
    int a=read();
	int b=read();
	if(a>b) swap(a,b);
	l=min(a,l);
	r=max(r,b);
    sum[a]++;sum[b+1]--;
	}
	for(int i=l;i<=r;i++)
	{
		ans[i]=ans[i-1]+sum[i];
		ma=max(ans[i],ma);
	}
	cout<<ma;
}
```
</details>
然后我大意地以为题目很简单。

## 透心凉T2

刚看到的时候，我脑子里迅速过了一遍二分与中位数两种思路，最后选择后者因为觉得~~码量少~~能锻炼思维，实在不行再二分。

然后我开始考虑公式推导，最开始我想把每个坐标都减去等待时间，但是题目让求坐标而不是时间，所以我用了距离数组统计距离，然后写完了以后样例没过。

我切换思路，先找到等候时间最大的点，然后将其余点等候时间差想成提前走动的时间，用贪心使时间最短，然后计算，~~所以样例又没过~~。
放段代码纪念一下：
<details>
<summary>点击查看代码</summary>

```
        sort(a+1,a+n+1,mp);	
		int ma=-11,cnt=0;
        for(int i=1;i<=n;i++)
        {
        	if(a[i].t>ma)
		  {
		  	ma=a[i].t;cnt=i;
		  }
		}
		for(int i=1;i<cnt;i++)
		a[i].i=min(a[cnt].i,a[i].i+=(ma-a[i].t));
		for(int i=cnt+1;i<=n;i++)
		a[i].i=max(a[cnt].i,a[i].i-=(ma-a[i].t));
		sort(a+1,a+n+1,mp);
		if(n&1) printf("%d\n",a[n/2+1]);
		else printf("%.1lf\n",(a[n/2].i+a[n/2+1].i)/2.0);
	}
}
```
</details>
我开始考虑二分，光速写出了代码以后样例都过，但是为防止寄掉还是在不超时的情况下在答案附近搜索（因为是一位小数，所以复杂度$O(10\times n)$是于是我自信满满的提交。

最后果然寄掉了……。
也放段代码纪念一下：
<details>
<summary>点击查看代码</summary>

```
bool ch(double x)
{
	double ans=0,sum=0;
	int m=floor(x);
	for(int j=1;j<=m;j++)
	{
		ans=max(ans,abs(a[j].i*1.0-x)+a[j].t);
	}
	for(int j=m+1;j<=n;j++)
	{
		sum=max(sum,abs(a[j].i*1.0-x)+a[j].t);
	}
	if(ans<sum) return 1;
	return 0;
}
int main()
{

        sort(a+1,a+n+1,mp);	
		double l=1,r=n;
		while(l+1<=r)
		{
			double mid=(l+r)/2.0;
			if(ch(mid)) l=mid;
			else r=mid;
		}
		l=max(0.0,floor(l)-10.0);
		r=ceil(l)+10;
		double ans=0,sum=0;
		 double q=1e7,w=a[1].i;
	    for(double i=l;i<=r;i+=0.1)
	    {		double ans=0;
	    	for(int j=1;j<=n;j++)
	    	{
	    		ans=max(ans,abs(a[j].i*1.0-i)+a[j].t);
			}
			if(ans<q)
			{
				q=ans;
				w=i;
			}
		}
		cout<<w<<endl;
	}
}
```
</details>
然后我知道了正解思路后，十分震惊，思路就差一点，但是思想已经跟不上了
正解代码
<details>
<summary>点击查看代码</summary>

```
#include<bits/stdc++.h>
using namespace std;
inline int read(){
int w=1,s=0;char ch=getchar();
while(!isdigit(ch)){if(ch=='-') w=-1;ch=getchar();}
while(isdigit(ch)){s=s*10+(ch-'0');ch=getchar();}
return w*s;}
int T,n;
struct no
{
	int i,t;
}a[500100];
bool mp(no x,no y)
{
	return x.i<y.i;
}
bool ch(double x)
{
	double ans=0,sum=0;
	int m=floor(x);
	for(int j=1;j<=m;j++)
	{
		ans=max(ans,abs(a[j].i*1.0-x)+a[j].t);
	}
	for(int j=m+1;j<=n;j++)
	{
		sum=max(sum,abs(a[j].i*1.0-x)+a[j].t);
	}
	if(ans<sum) return 1;
	return 0;
}
int main()
{
	freopen("banquet.in","r",stdin);
	freopen("banquet.out","w",stdout);
	cin>>T;
	while(T--)
	{
	    memset(a,0,sizeof a);
		n=read();
		for(int i=1;i<=n;i++)
		{
		  a[i].i=read();
		}
		int l=1e9+7,r=-1e9-7; 
		for(int i=1;i<=n;i++)
		{
		  a[i].t=read();
		  l=min(l,a[i].i-a[i].t);
		  r=max(r,a[i].i+a[i].t);
		}
       if((l+r)%2==0) printf("%d\n",(l+r)/2);
       else printf("%.1lf\n",(l+r)/2.0);
	}
} 
```
</details>
偏移量原来是这么算的啊。

然后我就倒下了。

## 拉开差距的T3

~~众所周知~~稍难一点的图论我都会头疼，不是不会，而是思路清晰的码不出来（图论题做的太少了，连个邻接表都不会）。

这道题我看出了思路是递归+直接查找后，看着 `for(int i=link[x];i;i=edge[i].nxt)` 默默发呆。然后就放弃了。

比赛结果表明，我是班里最不会图论的人了（QWQ）
代码不放了，太丢人。

## 无语的T4

这题我熟啊，不就是递归暴力+动归AC经典题目么，然后我打了暴力代码（笑，动归是什么，能吃么）。
放个代码纪念
<details>
<summary>点击查看代码</summary>

```
map<string,bool> mp;
bool ch(string t)
{
	int a[3000];
	memset(a,0,sizeof a);
	for(int i=1;i<=n;i++)
	{
		a[i]=t[i-1]-'0';
	}
	for(int i=1;i<=n;i++)
	{int q=0;
		for(int j=i;j<=n;j++)
		{
			q+=a[j];
			if(q==x)
			{
			int w=0;
			for(int k=j+1;k<=n;k++)
			{
				w+=a[k];
				if(w==y)
				{int e=0;
				for(int c=k+1;c<=n;c++)
				{
					e+=a[c];
					if(e==z)
					{
                     string h;
                     for(int i=1;i<=n;i++) h=h+char(a[i]+'0');
                     if(!mp[h])
					{
						mp[h]=1;
						return 1;
			     	}
					}
					break;
				}
			    }
			    else if(w>y) break;
			}
		    }
		    else if(q>x)
		   break;
		}
	}
	return 0;
}
void di(int x,string s)
{
	if(x==n+1)
	{
		if(ch(s))
		ans++;
		return ;
	}
	for(int i=0;i<=9;i++)
	{
		char c=char(i+'0');
		di(x+1,s+c);
	}
}

di(0,"");
cout<<ans;
}
```
</details>
我以为有很多人AC，结果发现：

![](https://img2023.cnblogs.com/blog/3059767/202304/3059767-20230430213836554-1421981559.png)

谁家普及组出紫题？

# 总结：继续练图论去吧。


```