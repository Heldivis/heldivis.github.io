# AtCoder Beginner Contest 346

[比赛页面](https://atcoder.jp/contests/abc346)

[toc]

---

初二大佬来惹。

赶脚好有压迫感 qwq。

## T1

暴力模拟。

秒了。

## T2

最开始想的是找循环节。

然后发现有点困难。

发现数据规模很小。

于是暴力计算 $2\times 10^6$ 次，如果不符合要求则判为无解。

## T3

发现值域很大，没法开数组。

考虑先算出总和，然后如果读入的数未出现，则减去。

可以开一个 `map` 维护。

注意每次只有在读入的数在范围内的时候才需要减去，不然会 WA。（样例数据还挺强没罚时）

## T4

考虑 DP。

定义数组 `f[i][0/1][0/1]` 表示前 $i$ 为，第 $i$ 位为 $0/1$，是否出现过相同相邻的情况。

转移：

```cpp
if (s[i] == '0') {
    f[i][0][0] = f[i - 1][1][0];
    f[i][1][0] = f[i - 1][0][0] + a[i];
    f[i][0][1] = min(f[i - 1][1][1];, f[i - 1][0][0]);
    f[i][1][1] = min(f[i][1][1], f[i - 1][1][0] + a[i]);
} else {
    f[i][0][0] = f[i - 1][1][0] + a[i];
    f[i][1][0] = f[i - 1][0][1] + a[i];
    f[i][0][1] = min(f[i - 1][1][1] + a[i], f[i - 1][0][0] + a[i]);
    f[i][1][1] = min(f[i - 1][0][1], f[i - 1][1][0]);
}
```

因为 "There is **exactly** one integer $i$…", 所以答案是 `min(f[n-1][0][1], f[n-1][1][1])`.

## T5

很熟悉的染色问题。

~~最开始考虑线段树。~~

正着染色因为有覆盖的情况，考虑倒着跑。

每一次染色操作对答案的贡献是没有被染色的行或列的数量。

可以再开两个变量 $col$ 和 $row$ 维护。

## T6

赛时~~摆了~~不会。

就是个二分套二分，比较好想出来。

## 总结

- 还是要注意 `freopen()` 问题，因为没去 `freopen()` 吃了一发罚时……
- F 题也不是不能写，赛时可以多想想。
